# formal language
words whose letters taken from alphabet, bell-formed according to specific set of rules
defined by formal grammar (eg. context-free grammar, regular grammar)

formal language theory: study internal structural patterns

## word over alphabet
alphabet: Set, can have infinite elements
word oer alphabet: finite sequence of letters

{ words over alphabet Σ } = Σ*
length of word = #letters
empty word: length = 0, e,ε

in logic, alphabet as vocabulary, word as formulas/sentences

## def
(possibly infinite) set of finite-length strings composed from a given alphabet
many languages described by rules, eg. regular language, context-free language

## example
formal language L, alphabet Σ = {0,1,2,3,4,5,6,7,8,9,+,=}
- every nonempty string not contains "+"/"=" not start with "0"
- string "0" is in L
- "=" iff |"="|=1 and separates two valid strings
- no other string in L

## constructions
L = Σ*, set of all words over Σ
L = {a}* = {aⁿ}, n ranges over natural numbers, aⁿ = a repeats n times
set of inputs upon certain Turing machine halts

## lang spec formalism
strings 
- generated by some formal grammar
- described by regular expression
- accepted by some automation (eg. Turing machine, finite state automaton)
- decision procedure produce answer YES

question:
can formalism X describe every lang that formalism Y can describe?
how difficult to decide if given word belong to lang described by formalism X?
how difficult to decide if lang from formalism X and Y same lang?

## operation on lang
1. standard set operation (union, intersection, complement)
2. element-wise applicaiton of string operation
  - concatenation L1̇̇.L2 in form vw, v=string from L1, w=string from L2
  - intersection: exist in both lang
  - complement: all strings over Σ not in L1

# language
## regular language
formal lang that can be expreseed by regular expression OR recongnized by finite automaton

Kleene's theorem: equivalence of regular expression and finite automata

## context free lang (CFL)
lang generated by context-free grammar

### deterministic CFL
CFL that 


# formal grammars
set of production rules for strings in formal language
rules describe how to form strings from alphabet that valid according to syntax

## def
finite set N (nonterminal symbols)
finite set Σ (terminal symbols)
finite set P (production rules)
- `(Σ ∪ N)*N(Σ ∪ N)* -> (Σ ∪ N)*`
- string of symbol -> string of symbol
distinguished symbol S ∈ N that start symbol (sentense symbol)

grammar formally defined as (N, Σ, P, S)
- rewriting system / phrase structure grammar

## math constructs
given grammar G = (N,Σ ,P, S), binary relation (=>G) on string (Σ ∪ N)*
"G derives in one step":
`x (=>G) y <=> ∃ u,v,p,q ∈ (Σ ∪ N)* : (x = upv) ∧ (p -> q ∈ P) ∧ (y = uqv)`

relation (*=>G) derives in >= 0 steps as relexive transitive closure (=>G)

sequential form x ∈ {ω ∈ (Σ ∪ N)* | S (*=>G) ω }
- member of (Σ ∪ N)* that can be dervied from finite steps from S
- sentence: no nonterminal symbol

L(G) language of G = sentences derived in finite steps from start symbol S

## example
rules P:
S -> aBSc
S -> abc
Ba -> aB
Bb -> bb

L(G) = {aⁿbⁿcⁿ | n ≥ 1} ,
`S (=>1) aB(S)c (=>2) a(Ba)bcc (=>3) aa(Bb)cc (=>4) aabbcc`

## Chomsky hierarchy
containment heirarchy of classes of formal grammars

## english example
terminals {generate, hate, great, green, ideas, linguists}
nonterminals {SENTENCE, NOUNPHRASE, VERBPHRASE, NOUN, VERB, ADJ}
production rules:
- SENTENCE -> NOUNPHRASE VERBPHRASE
- NOUNPHRASE -> ADJ NOUNPHRASE
- NOUNPHRASE -> NOUN
- VERBPHRASE -> VERB NOUNPHRASE
- VERBPHRASE -> VERB
- NOUN -> ideas / linguists
- VERB -> generate / hate
- ADJ -> great / green

derivation example:
SENTENCE -> NOUNPHRASE VERBPHRASE -> ADJ NOUNPHRASE VERB NOUNPHRASE 
-> ADJ NOUN VERB ADJ NOUN-> great linguists generate great ideas

syntactically correct sentence may not make sense

### hierarchy
| Grammar | languages              | automation                                      | production rules | example                                       |
| ------- | ---------------------- | ----------------------------------------------- | ---------------- | --------------------------------------------- |
| type 0  | recursively enumerable | turing machine                                  | αAβ -> β         | L={ω, ω describes terminating Turing machine } |
| type 1  | context-sensitive      | linear-bounded non-deterministic turing machine | αAβ -> αγβ       | L={aⁿbⁿcⁿ, n>0}                                |
| type 2  | context-free           | non-deterministic pushdown automaton            | A -> α           | L={aⁿbⁿ, n>0}                                  |
| type 3  | regular                | finite state automaton                           | A->a and A->aB   | L={aⁿ, n≥0}                                    |
where a=terminal, A,B=non-terminal, α,β,γ=terminal/non-terminal (α,β: maybe empty, γ:never empty)

regular ⊂ context-free ⊂ context-sensitive ⊂ recursively enumerable 

#### unrestricted grammar (type 0)
includes all formal grammars
1. recursively enumerable subset in { all possible words over alphabet of lang }
2. formal lang ∃ Turing machine that can halt (contrast to recursive lang )



#### context-sensitive grammar (type 1)
non-deterministic Turing machine whose tape bounded by contant × length of input

introduced to describe syntax of natural language

production rule: αAβ -> αγβ
α,β forms context of A, determine whether A can be replaced by γ or not 
- VS unrestricted: γ can be empty in unrestricted grammar
- VS context-free: context not taken into consieration



#### context-free grammars (type 2)
subset of determinstic context-free language: 
theoretical basis for phrase structure of most programming languages
- include context-sensitive name resolution due to declaration and scope
eg. LL parser

left side always nonterminal symbol
all rules are 1-1, 1-many, 1-none, applied regradless of context


#### regular grammar (type 3)
restrict rules to single non-terminal on left, single terminal on right


# foundation of language
## interpretive semantics
only syntax is generative, semantics is interpreted on this basis
keep deep-structure -- convert -- shallow-structure

## generative semantics
semantics is generative
higher abstraction for basic level

eg. Floyd broke the glass -> Floyd CAUSE ((the glass BROKEN) BECOME)


# formal semantics
## first order logic
### syntax
constants, variables
predicates, connectives (∧,∨,=>,<=>)
negation, quantifiers, functions, brackets




























