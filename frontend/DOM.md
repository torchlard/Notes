# fundamental
you can treat HTML DOM as classes of object that exist in browser,
with each object has properties (style, content)

JS has language binding with underlying C++ code in browser

# Tree
preorder, depth first traversal
children node: ordered set of objects

HTML namespace is: http://www.w3.org/1999/xhtml

# Events
events are dispatched to objects to signal an occurence (eg. network activity, user interaction)
implement EventTarget insterface, add event listener to observe events 

Event: objects, implement Event interface
`CustomEvent`: applications can dispatch events themselves
`preventDefault()`: terminate event, eg. form submission
`dispatchEvent()`: define own action after event dispatched

`capture`: target's ancestor response if capture=true
`bubble`: if true then ancestor will invoke event again

target: object that event is dispatched
currentTarget: obj that callback currently invoked

## properties
textContent: 
style

## practice
shouldn't use inline HTML event handler: bad practice
event handler less power, better cross-platform
DOM2 more powerful, less well supported (IE9)

## event object
automatically passed to event handler
```js
function bgchange(e) {
  e.target.style.backgroundColor = rndCol;
}
```

## prevent default
eg. user has some input data wrong when submit, need to stop submission
```js
form.onsubmit = function(e) {
  if (xxx) e.preventDefault();
}
```
`cancelable` attribute indicate whether event object can bve cancelled, if false, cannot call preventDefault()


## event bubbling and capture
two event handler of same event type is registered activated in one element

capturing phase: (discovery)
check outermost ancestor(document) if it has event handler -> next element inside -> ... -> element clicked

target phase:
- event object arrive at event target, if cannot bubble, terminate

bubbling phase: (register, run)
check if clicked element has onclick handler registered, run it if yes -> move to ancestor do same thing -> ..->html

all event handler registered in bubbling phase
```js
video.onclick = function(e){
  e.stopPropagation(); // event doesn't bubble further up
  video.play();
}
```

default action: usually performed after event dispatch completed

addEventListener(type, listener [, options])
options:
- capture: event dispatched to listener before dispatched to any EventTarget in DOM tree
- once: listener invoked at most once, then listener auto removed
- passive: listener will never call preventDefault

useCapture:
- true: follow capturing order (top->down)
- false: follow bubbling order (down->top)

## event delegation
a parent with multiple child elements, if you want to trigger event when click any one of child, instead of registering 
events to all children, only register the parent and set event listener bubble up
```js
document.getElementById("parent-list").addEventListener("click", function(e){
  if(e.target && e.target.nodeName == "LI"){
    console.log("list item " + e.target.id.replace("post-", "") + " was clicked" )
  }
})
```

## trusted event
if event generated by user action, then it's trusted; 
else event was created/modified by script / dispatch via dispatchEvent

## activation trigger
eg. `<a>` element triggered by click/keydown event
event based activation trigger: timer-based event activate at certian clock time

## types
ui, input, data

### UIEvent 
(interface, sync/async, bubble, trusted target, cancelable, default action, context(trusted events))
load, unload, abort, error, select

### HashChangeEvent
fired when fragment identifier of URL has changed (part of URL after #)


### Focus 
event order: focusin -> focus --(shift focus)--> focusout -> blur

### Mouse
readonly attr: (clientX, clientY, screenX, screenY, ctrlKey, shiftKey, altKey, metaKey, button, buttons)

client: relative to viewport associated with event || screen: relative to origin of screen coor system
button: 0 => primary button, 1 => auxiliary buttory(eg. middle btn, mosue wheel), 2 => secondary (right btn)
buttons: indicate combination of buttons currently being pressed, as bitmask
  eg. base units (0,1,2,4,..) for 3 = 1+2, means buttons 1,2 are pressed
relatedTarget: eg. focusin <-> focusout

modifier key support: (Fn, FnLock, NumLock, ScrollLock, Symbol, ...) 

order: mousemove -> mouseover -> mouseenter -> mouseenter -> mouseout -> mouseleave

type: click, dblclick, mousedown, mouseenter, mouseleave, mousemove, mouseout, mouseover, mouseup

when move out of inner element:
- mouseout: trigger listener of both inner and outer element
- mouseleave: only trigger inner element's listener

when mouse enters / leaves child element:
- mouseover: triggered
- mouseenter: not triggered

### Gamepad
attr: (axes, buttons, connected, displayId, id, index, mapping, timestamp)

### Wheel
attr: (deltaX, deltaY, deltaZ, deltaMode[unit indicator] )

### Drag

### Input
order: beforeinput -> input

### Keyboard
attr: (key[key value], code[string identify physical key pressed], location[key location], 
  repeat[repeating events keydown-beforeinput-input], isComposing, ctrlKey, shiftKey ...)

order: keydown -> beforeinput -> input -> keyup
type: keyup, keydown

### PageTransitionEvent
fired when document being loaded / unloaded
(persisted[if document loading from cache])

### PointerEvent
state of DOM event produced by pointer such as geometry of contact point
pointer = hardware agnostic representation of input device (mouse, pen, touch-enable device)

(pointerID, width[width of contact geometry], height, pressure[normalized pressure], tangentialPressure[cyliner stress], tiltX, tiltY,
 twist[clockwise rotation(eg. pen) around major axis] , pointerType, isPrimary[if pointer represent primary pointer of this type])

type: pointerover, pointerenter, pointerdown, pointermove, pointerup, pointercancel, pointerout, pointerleave, 
    gotpointercapture, lostpointercapture

### TouchEvent
event on touch-enable device
( {alt,ctrl,meta,shift}Key, targetTouches[touches currently in contact with surface], 
  touches[points of contact with surface, include target/changed status], changedTouches )

type: touchstart, touchend, touchmove, touchcancel

### TransitionEvent
events related to CSS transition
(propertyName, elapsedTime, pseudoElement)

### WebGLContextEvent
part of WebGL API, response to status change to WebGL rendering context


### Composition
provide means for inputing text in supplementary / alternate manner than Keyboard Events
eg. add accents to characters

compositionstart -> compositionupdate -> compositionend

### Blob
(data, timecode[time diference TS of first chunk data to first chunk in first BlobEvent] )

### Clipboard
cut, copy, paste

### DeviceLight, DeviceMotion, DeviceOrientation, DeviceProximity

### Fecth
work with service worker on global scope
tell how receiver will treat the response, by `event.respondWith()`

### IDBVersionChangeEvent
IndexDB related

### MessageEvent
web-worker specific

represent messages in
- server-sent
- web socket
- cross-document messaging
- channel messaging
- cross-worker/document messaging
- broadcast channel
- WebRTC data channel

### PopStateEvent
everytime active history record changed, popstate event will be sent to window

background: html5 add `history.pushState()`, `history.replaceState()` methods to add/modify history record
  when using pushState, change referrer of XMLHttpRequest

### ProgressEvent
measuring process of an underlying process, eg. XMLHttpRequest, img, audio, video, style, link
(lengthComputable, loaded, total[total amount of work])



# WebRTC
direct communication among clients, not need bypass server like web-socket
first exchange info, identified via server, then direct communication via NAT traversal
UDP protocol, encrpted

## ICE (Interactive Connectivity Establishment)
framework that allow clients to connect, can use ICE to bypass firewall
even no public IP address, can use address provided by ICE / by intermediate server

## STUN (Session Traversal Utilities for NAT)
kind of protocol that find your public IP, determine if your router allow to connect to client
client sent request to STUN server, it will return client's public address

## NAT (Network Address Translation)
provide public IP to your device having private IP

## TURN (Traversal Using Relays around NAT)
last solution for TURN server to redirect packet to you

## SDP (Session Description Protocol)
describe multimedia metadata (codec, format, encrypt, resolution) in connection

## Offer/Answer
Offer: client A want to setup connection, sent offer to client B via signal channel
Answer: client B receive offer, response with Answer

## ICE candidate
Offer/Answer exchange multimedia metadata
ICE candidate exchange information how to connect point to point

### RTCDataChannelEvent
represent datachannel event
sent RTCPeerConnection when remote peer asking to open RTCDataChannel between two peers

no need to construct RTCDataChannelEvent yourself
allow you to just listen for datachannel event and when you receive it, gain access to opened data channel

### RTCPeerConnectionIceEvent
occur in relation to ICE candidate with target


# Browser object
## Navigator
state and identity of user agent 
allow script to query and register themselvess to carry on some activities

### usage
eg. window.navigator.platform
-> show your OS version "Linux x86_64"

### API
(appCodeName, appName, connection, ...)

## Window
opened window in browser, point to DOM document loaded 
for every frame/iframe created, will create new window for them
each tab is separate window

### API
scroll, scrollTo, screen, self, print, prompt, postMessage
resizeTo, innerHeight: apply to whole window, not specific tab

### window.history
- go(): go to certain page in history
- back(): back to previous page
- forward(): go to next page

### window.location
include info about current URL
- hash, host, hostname, href, pathname, port, protocol, search

## Screen
represent screen, usually one on which current window is being rendered
`window.screen`


# DOM
JS is event driven async programming model, when file, browser, element has sth happen, browser
will emit corresponding events => fundamentals of interaction JS <-> DOM

DOM element support various events -> can use listener to add handler
- can add by means of DOM0 / DOM2
event name: click, load, mouseover

## constitution
- core DOM
- XML DOM
- HTML DOM

## DOM 0
early version of js interact with web API
eg. images, forms
exist before W3C standard

start with 'on' => onclick, onload ...
`<input type="button" value="xx" onclick="showMsg()"/>`

delete event:
`btn.onclick = null;`

## DOM 1
W3C standard DOM (first version)
DOM core: structure of XML document
DOM HTML: extension on top of DOM core (eg. document object)
xml namespace

## DOM 2
more interaction, UI event, iteration, CSS support

addEventListener(), removeEventListener()
`btn.addEventListener("click", showMsg, false);`

- DOM Core
extend functionality of DOM1 core
- DOM Views
programs to dynamically access and update content of representation
           in document => {AbstractView, DocumentView}
- DOM Events
generic event system, with concepts (event flow: capture > target > bubbling, cancellation) 
- DOM CSS/Style
program/script to dynamically access and update content of stylesheet
- DOM traversal and range
program to dynamically traverse and identify range of content in document

## DOM 3
DOM load and save
DOM validation
DOM style 


















