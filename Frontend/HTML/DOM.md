# fundamental
you can treat HTML DOM as classes of object that exist in browser,
with each object has properties (style, content)

JS has language binding with underlying C++ code in browser

# Tree
preorder, depth first traversal
children node: ordered set of objects

HTML namespace is: http://www.w3.org/1999/xhtml

# Events
events are dispatched to objects to signal an occurence (eg. network activity, user interaction)
implement EventTarget insterface, add event listener to observe events 

Event: objects, implement Event interface
`CustomEvent`: applications can dispatch events themselves
`preventDefault()`: terminate event, eg. form submission
`dispatchEvent()`: define own action after event dispatched

`capture`: target's ancestor response if capture=true
`bubble`: if true then ancestor will invoke event again

target: object that event is dispatched
currentTarget: obj that callback currently invoked

## properties
textContent: 
style

## practice
shouldn't use inline HTML event handler: bad practice
event handler less power, better cross-platform
DOM2 more powerful, less well supported (IE9)

## event object
automatically passed to event handler
```js
function bgchange(e) {
  e.target.style.backgroundColor = rndCol;
}
```

## prevent default
eg. user has some input data wrong when submit, need to stop submission
```js
form.onsubmit = function(e) {
  if (xxx) e.preventDefault();
}
```
`cancelable` attribute indicate whether event object can bve cancelled, if false, cannot call preventDefault()


## event bubbling and capture
two event handler of same event type is registered activated in one element

capturing phase: (discovery)
check outermost ancestor(document) if it has event handler -> next element inside -> ... -> element clicked

target phase:
- event object arrive at event target, if cannot bubble, terminate

bubbling phase: (register, run)
check if clicked element has onclick handler registered, run it if yes -> move to ancestor do same thing -> ..->html

all event handler registered in bubbling phase
```js
video.onclick = function(e){
  e.stopPropagation(); // event doesn't bubble further up
  video.play();
}
```

default action: usually performed after event dispatch completed

addEventListener(type, listener [, options])
options:
- capture: event dispatched to listener before dispatched to any EventTarget in DOM tree
- once: listener invoked at most once, then listener auto removed
- passive: listener will never call preventDefault

useCapture:
- true: follow capturing order (top->down)
- false: follow bubbling order (down->top)

## event delegation
a parent with multiple child elements, if you want to trigger event when click any one of child, instead of registering 
events to all children, only register the parent and set event listener bubble up
```js
document.getElementById("parent-list").addEventListener("click", function(e){
  if(e.target && e.target.nodeName == "LI"){
    console.log("list item " + e.target.id.replace("post-", "") + " was clicked" )
  }
})
```

## trusted event
if event generated by user action, then it's trusted; 
else event was created/modified by script / dispatch via dispatchEvent

## activation trigger
eg. `<a>` element triggered by click/keydown event
event based activation trigger: timer-based event activate at certian clock time

## types
ui, input, data

### UIEvent 
(interface, sync/async, bubble, trusted target, cancelable, default action, context(trusted events))
load, unload, abort, error, select

### HashChangeEvent
fired when fragment identifier of URL has changed (part of URL after #)


### Focus 
event order: focusin -> focus --(shift focus)--> focusout -> blur

### Mouse
readonly attr: (clientX, clientY, screenX, screenY, ctrlKey, shiftKey, altKey, metaKey, button, buttons)

client: relative to viewport associated with event || screen: relative to origin of screen coor system
button: 0 => primary button, 1 => auxiliary buttory(eg. middle btn, mosue wheel), 2 => secondary (right btn)
buttons: indicate combination of buttons currently being pressed, as bitmask
  eg. base units (0,1,2,4,..) for 3 = 1+2, means buttons 1,2 are pressed
relatedTarget: eg. focusin <-> focusout

modifier key support: (Fn, FnLock, NumLock, ScrollLock, Symbol, ...) 

order: mousemove -> mouseover -> mouseenter -> mouseenter -> mouseout -> mouseleave

type: click, dblclick, mousedown, mouseenter, mouseleave, mousemove, mouseout, mouseover, mouseup

when move out of inner element:
- mouseout: trigger listener of both inner and outer element
- mouseleave: only trigger inner element's listener

when mouse enters / leaves child element:
- mouseover: triggered
- mouseenter: not triggered

### Gamepad
attr: (axes, buttons, connected, displayId, id, index, mapping, timestamp)

### Wheel
attr: (deltaX, deltaY, deltaZ, deltaMode[unit indicator] )

### Drag

### Input
order: beforeinput -> input

### Keyboard
attr: (key[key value], code[string identify physical key pressed], location[key location], 
  repeat[repeating events keydown-beforeinput-input], isComposing, ctrlKey, shiftKey ...)

order: keydown -> beforeinput -> input -> keyup
type: keyup, keydown

### PageTransitionEvent
fired when document being loaded / unloaded
(persisted[if document loading from cache])

### PointerEvent
state of DOM event produced by pointer such as geometry of contact point
pointer = hardware agnostic representation of input device (mouse, pen, touch-enable device)

(pointerID, width[width of contact geometry], height, pressure[normalized pressure], tangentialPressure[cyliner stress], tiltX, tiltY,
 twist[clockwise rotation(eg. pen) around major axis] , pointerType, isPrimary[if pointer represent primary pointer of this type])

type: pointerover, pointerenter, pointerdown, pointermove, pointerup, pointercancel, pointerout, pointerleave, 
    gotpointercapture, lostpointercapture

### TouchEvent
event on touch-enable device
( {alt,ctrl,meta,shift}Key, targetTouches[touches currently in contact with surface], 
  touches[points of contact with surface, include target/changed status], changedTouches )

type: touchstart, touchend, touchmove, touchcancel

### TransitionEvent
events related to CSS transition
(propertyName, elapsedTime, pseudoElement)

### WebGLContextEvent
part of WebGL API, response to status change to WebGL rendering context


### Composition
provide means for inputing text in supplementary / alternate manner than Keyboard Events
eg. add accents to characters

compositionstart -> compositionupdate -> compositionend

### Blob
(data, timecode[time diference TS of first chunk data to first chunk in first BlobEvent] )

### Clipboard
cut, copy, paste

### DeviceLight, DeviceMotion, DeviceOrientation, DeviceProximity

### Fecth
work with service worker on global scope
tell how receiver will treat the response, by `event.respondWith()`

### IDBVersionChangeEvent
IndexDB related

### MessageEvent
web-worker specific

represent messages in
- server-sent
- web socket
- cross-document messaging
- channel messaging
- cross-worker/document messaging
- broadcast channel
- WebRTC data channel

### PopStateEvent
everytime active history record changed, popstate event will be sent to window

background: html5 add `history.pushState()`, `history.replaceState()` methods to add/modify history record
  when using pushState, change referrer of XMLHttpRequest

### ProgressEvent
measuring process of an underlying process, eg. XMLHttpRequest, img, audio, video, style, link
(lengthComputable, loaded, total[total amount of work])



# WebRTC
direct communication among clients, not need bypass server like web-socket
first exchange info, identified via server, then direct communication via NAT traversal
UDP protocol, encrpted

## ICE (Interactive Connectivity Establishment)
framework that allow clients to connect, can use ICE to bypass firewall
even no public IP address, can use address provided by ICE / by intermediate server

## STUN (Session Traversal Utilities for NAT)
kind of protocol that find your public IP, determine if your router allow to connect to client
client sent request to STUN server, it will return client's public address

## NAT (Network Address Translation)
provide public IP to your device having private IP

## TURN (Traversal Using Relays around NAT)
last solution for TURN server to redirect packet to you

## SDP (Session Description Protocol)
describe multimedia metadata (codec, format, encrypt, resolution) in connection

## Offer/Answer
Offer: client A want to setup connection, sent offer to client B via signal channel
Answer: client B receive offer, response with Answer

## ICE candidate
Offer/Answer exchange multimedia metadata
ICE candidate exchange information how to connect point to point

### RTCDataChannelEvent
represent datachannel event
sent RTCPeerConnection when remote peer asking to open RTCDataChannel between two peers

no need to construct RTCDataChannelEvent yourself
allow you to just listen for datachannel event and when you receive it, gain access to opened data channel

### RTCPeerConnectionIceEvent
occur in relation to ICE candidate with target


# Browser object
## Navigator
state and identity of user agent 
allow script to query and register themselvess to carry on some activities

### usage
eg. window.navigator.platform
-> show your OS version "Linux x86_64"

### API
(appCodeName, appName, connection, ...)

## Window
opened window in browser, point to DOM document loaded 
for every frame/iframe created, will create new window for them
each tab is separate window

### API
scroll, scrollTo, screen, self, print, prompt, postMessage
resizeTo, innerHeight: apply to whole window, not specific tab

### window.history
- go(): go to certain page in history
- back(): back to previous page
- forward(): go to next page

### window.location
include info about current URL
- hash, host, hostname, href, pathname, port, protocol, search

## Screen
represent screen, usually one on which current window is being rendered
`window.screen`


# DOM
JS is event driven async programming model, when file, browser, element has sth happen, browser
will emit corresponding events => fundamentals of interaction JS <-> DOM

strictly speaking, DOM not belongs to JS

DOM element support various events -> can use listener to add handler
- can add by means of DOM0 / DOM2
event name: click, load, mouseover

## constitution
- core DOM
- XML DOM
- HTML DOM

## DOM 0
early version of js interact with web API
eg. images, forms
exist before W3C standard, have IE & Netscape versions

start with 'on' => onclick, onload ...
`<input type="button" value="xx" onclick="showMsg()"/>`

delete event:
`btn.onclick = null;`

## DOM 1 [1998] {full support}
W3C standard DOM (first version)
DOM core: structure of XML document
DOM HTML: extension on top of DOM core (eg. document object)
xml namespace

## DOM 2 [2000] {full support}
more interaction, UI event, iteration, CSS support
HTML 4, XHTML 1

addEventListener(), removeEventListener()
`btn.addEventListener("click", showMsg, false);`

- DOM Core
extend functionality of DOM1 core
- DOM Views
programs to dynamically access and update content of representation
           in document => {AbstractView, DocumentView}
- DOM Events
generic event system, with concepts (event flow: capture > target > bubbling, cancellation) 
- DOM CSS/Style
program/script to dynamically access and update content of stylesheet
- DOM traversal and range
program to dynamically traverse and identify range of content in document
  {NodeIterator, TreeWalker}
range: +-/modify/insert range of content in document, DocumentFragment, Attr 

## DOM 3 [2004] {partial support}
- DOM Core
extend DOM1,DOM2 core, add {adoptNode(), textContent, baseURI ...}
- DOM load and save
programs to dynamically load content of XML document into DOM document
serialize DOM document to XML document
- DOM validation
program to dynamically update content and structure, while ensuring document remains valid
- DOM event 
extend DOM2 event, focus on keyboard event, how to handle them
- DOM3 XPath
~ functionality access DOM tree using XPath 1.0
focus on XML document itself, how to locate path of xml node

## DOM 4 [2015 ..] {not yet finalized}
- parent node
prepend, append
- child node
before(node): add node before
after(node): add node after
remove(): remove node itself
replaceWith(sth): replace node with sth
- fixes
toggleAttribute
DOM Listener: {capture: true, passive: false}: 
  event.preventDefault(), capture phase 
normalized KeyboardEvent, MouseEvent
element.matches(selectorString)
element.closest(selector): get closest matching ancestor
classList
CustomEvent
requestAnimationFrame, cancelAnimationFrame

# special entity in DOM
## CDATA
```html
<sender>John Smith</sender>

<![CDATA[<sender>John Smith</sender>]]>
```
everything inside CDATA treated as text in html

## entity
reserved characters in HTML must be replaced with character entities
eg. `<` -> `&lt`

## processing instruction
embed application specific instructions in XML which can be ignored by other 
  applications that don't recognize them

# implementation
since most API in specification are interface rather than class
=> only need to expose methods with defined names and specified operations
=> ordinary constructor in C++ sense cannot be used to create DOM objects
==> compatible with wide range of language (scripting / programming language)

# Shadow DOM
question: there's only video tag with source tag, where are play/pause button, progress bar come from?
ans: shadow DOM 

allow document to insert dom tree during rendering, but it is not part of main DOM tree
- adv: good encapsulation, outer CSS cannot affect DOM inside shadow root

## shadow boundary
any html and css inside shadow root protected from parent document by shadow boundary

nothing within template is rendered on page until activate it using JS

## slot
browser default only render shadow DOM's shadow tree, not other parts in original shadow DOM
to keep other parts, need to use `<slot>` element, like container for shadow tree

<<<<<<< HEAD
# Web component
convention: for undefined element, treat them same as standard element, 
without default styles and behaviors

## custom elements
types
1. autonomous custom elements (standalone, not inherit from standard HTML elements)
`document.createElement("popup-info")`
2. customized built-in elements (inherited)
`<p is="word-count">, document.createElement("p", {is: "word-count"}`

### autonomous
```js
class PopupInfo extends HTMLElement {
  constructor(){
    super(); // always call first
  }
  // write element functionality here
}
```

### lifecycle callbacks
connectedCallback
disconnectedCallback
attributeChangedCallback

### what required?
1. custom elements initialized by `<custom></custom>, new CustomElement(), document.create...`
2. can use original method to operate custom elements (eg. document.body.appendChild), can modify by CSS
3. have lifecycle hooks

can use `<slot name="top"></slot>` in DOM
  to reference to `<ul slot="top"></ul>` in shadow tree

## custom element
sometimes we do not need to create new element, only need to extend based on existing element


## link VS @import
link belongs to XHMTL, can load CSS, define RSS,rel
@import: only can load CSS [CSS 2.1]
- when page loaded, link also loaded
- @import loaded after page loaded





