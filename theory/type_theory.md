λΦ≡ΣΠ

# type theory VS set theory
- set theory need first class logic embedded
- type theory is its own deductive system 
deductive system = collection of rules for deriving things (judgment)

prove theorem = construct an object
A has a proof = a: A ~~ a ∈ A in set

a: A is judgment; a ∈ A is proposition
in type theory, cannot say "if a: A then not case that b: B", nor disprove judgment "a: A" 

cannot talk about element "a" in isolation
every element must be element of some type

"let x be natural number"
- set theory: "let x be a thing" AND "assume that x ∈ N"
- type theory: "let x: N" (atomic statement)

in type theory, propositions are type => equality is a type
a,b: A => "a =_A b"
IF "a =(A) b", then a and b are (propositionally) equal

## equality 
judgmental equality / definitional equality: a ≡ b
VS propositional equality

"p: (x = y)", "A ≡ (x=y)"
"f: A -> B" = f has type (A -> B)

## context
assume x,y: A, p: x =(A) y; => construct an element p^-1: y =(A) x
context = collection of all such assumptions
        = ordered list of assumption

## rules
set theory: only rules are rules of first-order logic
- all information about behavior of set contained in axiom

type theory: rules which contains all information, axiom not necessary
- At the end, need extra univalence axiom

# function types
in type thory, function not defined as functional relations, but are primitive concept
construt element of A -> B
1. direct definition
2. λ-calculus

introduce a function by giving it a name
  f(x) = Φ  where A -> B
x = variable, Φ = expression
check Φ: B, x: A
compute f(a) by replacing variable x in Φ with a

λ-abstraction: not introduce name for function
`(λ(x: A).Φ): A -> B`

if f(x) = x+x, then `(λ(x: N).x+x): N -> N`
`λ(x: N).x+x)(2) = 2 + 2`

const function `λ(x: A).y: A -> B` for any y:B
generally omit tiype and write `λx.Φ`

equivalent notation `(x |-> Φ): A -> B`
`g(x,-)` = `λy.g(x,y)`

`f ≡ (λx.f(x))` define function that applies f to its argument

## binding structure
insvisible link generated by binders such as λ,Π,Σ between place where variable is introduced and used

## currying
f: A -> (B -> C)  =  f: A -> B -> C
represent function of 2 inputs a:A, b:B as function take 1 input a:A, return another function
- apply f to a first, then apply result to b => `f(a)(b): C`

`f(x,y) = Φ` = `f = λx.λy.Φ` = `f = x |-> y |-> Φ` = `f(-,-)`


# universe
universe = type whose elements are types
in set theory, for universe of all types => Russell's paradox
- to avoid paradox, introduce hierarchy of universe `U0: U1: U2 ...`
- cumulative universe, next universe contains previous universe
- write `A: U` and omit level

families of types / dependent type = `B: A -> U`
eg. family of finite sets `Fin: N -> U`, where Fin(n) is type with exactly n elements

constant type family = `(λ(x: A).B): A -> U`

# dependent function type (Π)
dependent function = functions whose codomain type vary depending on element of domain 

given A:U, family B:A->U, construct dependent function type
`Π(x:A) B(x):U` = `Π(x:A),B(x)` = `Π(x:A) B(x)`

if B is constant family, then `Π(x:A) B ≡ (A -> B)`
λ-abstarction: `λx.Φ : Π(x:A) B(x)`

eg. function returns "largest" element of nonempty finite type
`fmax: Π(n:N) Fin(n+1)` = `fmax(n) = n_(n+1)`

## polymorphic function
takes type as one of its arguments, act on element of that type
`id: Π(A:U) A->A`   define `id_A(x) = x`

`swap: Π(A:U) Π(B:U) Π(C:U) (A->B->C) -> (B->A->C)`
define as `swap(A,B,C,g) = λb.λa.g(a)(b)`

another possibility: `Π(x:A) Π(y:B(x)) C(x,y)`
given a:A, b:B(a) => `f(a)(b): C(a,b)`


# Product type
cartesian product = given A,B:U, introduce AxB: U
unit type (nullary product type) = 1:U

ordered pair is primitive concept in type theory

## generic way introduce new type
1. formation rules
`A->B` if both A,B are types
`Π(x:A) B(x)` when A,B(x) are types
2. construct elements of that type (constructor/introduciton rule)
`f(x) = 2x`
3. use elements of that type (eliminators/elimination rule)
4. computation rule
express how eliminator act on constructor
`(λx.Φ)(a)`
5. (optional) uniqueness principle
uniqueness of maps into or out of that type
every element of type uniquely determined by results of applying eliminator to it
- reconstructed from results by applying constructor
propositional uniqueness principle: if provable as propositional equality from other rules of type 

##
given `g: A -> B -> C`
define `f: A x B -> C` by `f((a,b)) = g(a)(b)`

category theory: define product A x B to be left adjoint to "exponential" B -> C

## projection function
pr1: A x B -> A     pr1((a,b)) = a
pr2: A x B -> B     pr2((a,b)) = b

we can invoke function definition once, in universal case => apply resulting fn in other cases

define `rec[AxB]: Π[C:U](A->B->C) -> AxBxC`  by `rec[AxB](C,g,(a,b)) = g(a)(b)`
then `pr1 = rec[AxB](A, λa.λb.a)`, `pr2 = rec[AxB](B, λa.λb.b)`
recursor = `rec[AxB]`


## dependent fn over product type
generalize recursor
given `C: A x B -> U`
define `f: Π[x:AxB] C(x)` by `g: Π[x:A]Π[y:B] C((x,y))`
with `f((x,y)) = g(x)(y)`

prove propositional uniqueness: every element of AxB = a pair
```
uniq[AxB]: Π[x:AxB] ( (pr1(x), pr2(x)) =[AxB] x )
uniq[AxB]((a,b)) = refl[(a,b)]

refl[(a,b)]: (pr1((a,b)), pr2((a,b))) = (a,b)
```
prove a property for all elements of a product
eg. for natural numbers, ability to write proofs by induction
given A,B:U, `ind[AxB]: Π[C: AxB->U] ( Π[x:A] Π[y:B] C((x,y)) ) -> Π[x:AxB] C(x)`
by `ind[AxB] (C,g,(a,b)) = g(a)(b)`

dependent funciton defined on pairs being obtained from induction principle of cartesian product
recursor = special case of induction where family C = const
induction = (dependent) eliminator
recursion = non-dependent eliminator

define `ind[1]: Π[C:1->U] C(*) -> Π[x:1] C(x)` by `ind1(C,c,*) = c`
only inhabitant is *, so to construct `uniq[1]: Π[x:1] x = *` by `uniq[1](*) = refl[*]`
or using induction `uniq[1] = ind[1](λx.x = *, refl[*])`


# dependent pair type Σ
generalize product type to allow 2nd component of pair vary by choice of 1st component
given A:U, B:A->U  `Σ[x:A]B(x)`
have `(a,b): Σ[x:A] B(x)` given `a:A, b:B(a)`
`Σ[x:A]B = A x B`

```
pr1: Σ[x:A]B(x) -> A
pr1((a,b)) = a

C: Σ[x:A]B(x) -> U
g: Π[a:A] Π[b:B(a)] C((a,b))

f: Π[p: Σ[x:A] B(x)] C(p)
f((a,b)) = g(a)(b)

pr2: Π[p:Σ[x:A] B(x)] B(pr1(p))
pr2((a,b)) = b

ind[Σ[x:A] B(x)]: Π[C: Σ[x:A]B(x)->U] (Π[a:A]Π[b:B(a)] C((a,b))) -> Π[p:Σ[x:A]B(x)] C(p)
```
if dependent fn g, assign each a:A depdendnet pair (b,r), where b:B, r:R(a,b)
then f:A->B; dependent fn assign to a:A that R(a,f(a))

type-theoretic axiom of choice can be proven directly from rules of type theory

## magma
definition: a,b ∈ M => a∙b ∈ M  (∙ = operation)
define binary operation `m: A -> A -> A`
magma = pair (A,m) consist of type A:U & operation m
```
magma = Σ[A:U] (A -> A -> A)
pointed magma = Σ[A:U] (A -> A -> A) x A
```
can extract magma's underlying type with projections pr1,pr2

for structure >2 piece of data, use iterated pair type, maybe only partially dependent
eg. (x,y,z,w) = (x,(y,(z,w)))


# Coproduct

















